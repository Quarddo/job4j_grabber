package ru.job4j.gc;

public class User {
    private String name;
    private int age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    protected void finalize() throws Throwable {
        System.out.printf("Removed %s %d%n", name, age);
        super.finalize();

    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
/**
 * Для каждого объекта JVM хранит:
 * 1) Заголовок объекта
 * 2) Память для примитивных типов
 * 3) Память для ссылочных типов
 * 4) Смещение/выравниваниеОбъект
 *
 * Размер заголовка 8 байт(32-х разрядная система) 16 байт(64-х рахрядная система)
 *
 * byte 1 byte
 * short 2  byte
 * int 4 byte
 * long 8 byte
 * char 2 byte
 * float 4 byte
 * double 8 byte
 * boolean 1 bit
 *
 * 1. new User("Петр", 27)
 * Заголовок: 8 байт (16 байт) в зависимости от разрядности системы
 * Выравнивание для кратности: 4 байта (0 байт)
 * Переменная приметивного типа int: 4 байта
 * поле age = 4 байта
 * Поле ссылочного типа String:
 *      заголовок: 8 байт (16 байт)
 *      поля int внутри класса String (offset, count, hash code): 4 байта * 3 = 12 байт
 *      ссылочная переменная на объект массива: 4 байта (8 байт)
 *      размер массива символов(примитивов сhar): 2 байта * 4 = 8 байт
 *   поле name = 30 байт (42 байта)
 * Итого (32-х): 8 + 4 + 4 + 8 + 12 + 4 + 8 = 48 байт
 * Итого (64-х): 16 + 4 + 16 + 12 + 8 + 8 = 64 байт
 *
 * 2. В памяти JVM пустой объект равен размеру заголовка:
 *    32-х битной 8 байт
 *    64-х битной 16 байт
 *
 * 3. Что бы добится самостоятельного вызова сборщика мусора за счет ключей Xmx, нужно заполнить выделяемую память
 * например для хипа -Xmx4m -Xms4m (4мб), при создании более ~ 8200 объектов
 * Сбоорка мусора произойдет, когда заполнится вся областьпамяти для молодого поколения используется minor GS, а для старого
 * majorGC.
 * Созданные объекты попадают в кучу(heap), где делятся на поколения(generation) и поподают в eden
 * до тех пора пока он не заполнится, при его заполнении объекты не имеющие ссылку будут удалены(minor GC),a имеющие
 * попадают в survivor space(s0, s1), таким образом происходит процесс "старения" объектов которые дальше перходят в old generation
 * где они будут хранится так же до заполнения после чего произойдет удаление(major GC)
 */